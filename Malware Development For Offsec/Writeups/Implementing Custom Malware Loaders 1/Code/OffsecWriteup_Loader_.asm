
MySegment segment read write execute
;Function Prototype: void* DllModuleBaseFinder_(char* ModuleName, unsigned int LenModuleName);
DllModuleBaseFinder_ proc

;check the name of the dll to find
	push rsi
	push rdi
	xor r8, r8
	xor r9, r9
	xor r10, r10
	xor r11, r11

	mov r8, gs:[30h]									;retrieve address of TEB
	mov r9, [r8+60h]									; store PEB address
	mov r10, qword ptr [r9+18h]							; pointer to _PEB_LDR_DATA
	mov r8, qword ptr [r10+10h]							; pointer to InLoadOrderModuleList
	mov r9, rcx											; pointer ntdll string

DO_AGAIN:
	mov r10, qword ptr [r8+60h]							; address of Buffer inside struct FullDllName embedded inside _LDR_DATA_TABLE_ENTRY struct										 
	mov rsi, r9
	mov rdi, r10										; pointer retrieved module name
	mov rcx, rdx										; length of string
	cld													; clear direction flag, will cause ESI and EDI to be incremented during string operation
	repe cmpsw											; compare string byte by byte
	jrcxz GetBaseAddressDll								; jump when end of string reached
	mov r8, qword ptr[r8]								; repeat comparison if library name not found
	jmp DO_AGAIN

GetBaseAddressDll:
;get the base address of the dll
	mov rax, qword ptr [r8+30h]							; move the base address of the dll 
	pop rdi
	pop rsi
	ret
	
DllModuleBaseFinder_ endp

;Function Prototype: int SyscallBaseFinder_(unsigned long long ReturnedDllBase, char* NtApiName, size_t LenNtApiName);
SyscallIdFinder_ proc

	push rbx
	push r12
	push r13
	
	xor r9, r9
	xor r10, r10
	xor r11, r11
	
	lea r9, [rcx]												;; save DllBaseAddr
	lea r13, [rdx]											;; save pointer NtApiName
	mov rbx, r8												;; save len

	mov r10d, dword ptr [r9+03ch]							;; r8+3ch = e_lfanew (offset to NT Header)
	
	mov r11d, dword ptr [r9+r10+018h+070h]					; base + [base+3ch] + 18h + 70h? = pointer to export table
	lea r11, [r9+r11]										; Virtual address Export Table
	mov r12d, dword ptr [r11+020h]							; pointer to function names array
	lea r12, [r9+r12]
	xor rdx, rdx

RepeatCheck:
	mov edi, dword ptr [r12+rdx*4]							;; address of name of the first API
	lea rdi, [r9+rdi]										; address of API name
	lea rsi, [r13]											;reload rsi with API name
	
	
	xor rcx, rcx
CompareNextByte:
	mov al, byte ptr[rsi+rcx]
	cmp byte ptr[rdi+rcx], al
	jne NextString
	inc rcx
	cmp rcx, r8
	jge ApiFound	
	jmp CompareNextByte
NextString:
	inc rdx
	jmp RepeatCheck		
	
	
	
;	mov rcx, r8
;	cld	
;	repe cmpsb 												; compare passed API name with API name in export table -> Address of Names Array				
;	cmp rcx, 0							
;	jl ApiFound	
;	;jrcxz ApiFound
;	inc rdx
;	jmp RepeatCheck
	
; provide exit condition if API name not found	
	
ApiFound:
	mov r10d, dword ptr [r11+024h]							; Virtual offset Address of name  ordinals field
	lea r10, [r9+r10]										; pointer to array address of name ordinals 
	mov r12w, word ptr[r10+rdx*2]							; ordinal number
	movzx r12, r12w
	mov r10d, dword ptr [r11+01ch]							; Virtual offset Address of Functions name field
	lea r10, [r9+r10]										; pointer to function array	
	mov r10d, dword ptr[r10+r12*4]							; Api Address VirtualOffset
	lea r10, [r9+r10]
	mov rax, r10
	
	cmp byte ptr [rax], 048h								; check if already patched 
	je AfterPatchingSyscallId
	jmp BeforePatchingSyscallId
	
	
AfterPatchingSyscallId:
	mov eax, dword ptr [rax+12]								; After patching syscallid is 12 offset from API base								;syscall ID
 	jmp Exit
BeforePatchingSyscallId:
	mov eax, dword ptr [rax+4]
Exit:
	pop r13
	pop r12
	pop rbx
	ret
	
SyscallIdFinder_ endp

SyscallBaseFinder_ proc

	push rbx
	push r12
	push r13
	
	xor r9, r9
	xor r10, r10
	xor r11, r11
	
	lea r9, [rcx]												;; save DllBaseAddr
	lea r13, [rdx]											;; save pointer NtApiName
	mov rbx, r8												;; save len

	mov r10d, dword ptr [r9+03ch]							;; r8+3ch = e_lfanew (offset to NT Header)
	
	mov r11d, dword ptr [r9+r10+018h+070h]					; base + [base+3ch] + 18h + 70h? = pointer to export table
	lea r11, [r9+r11]										; Virtual address Export Table
	mov r12d, dword ptr [r11+020h]							; pointer to function names array
	lea r12, [r9+r12]
	xor rdx, rdx

RepeatCheck:
	mov edi, dword ptr [r12+rdx*4]							;; address of name of the first API
	lea rdi, [r9+rdi]										; address of API name
	lea rsi, [r13]											;	reload rsi with API name
	
	xor rcx, rcx
CompareNextByte:
	mov al, byte ptr[rsi+rcx]
	cmp byte ptr[rdi+rcx], al
	jne NextString
	inc rcx
	cmp rcx, r8
	jge ApiFound	
	jmp CompareNextByte
NextString:
	inc rdx
	jmp RepeatCheck	
	
	;mov rcx, r8
	;cld	
	;repe cmpsb
	;jrcxz ApiFound
	;inc rdx
	;jmp RepeatCheck
	
; provide exit condition if API name not found	
	
ApiFound:
	mov r10d, dword ptr [r11+024h]							; Virtual offset Address of name  ordinals field
	lea r10, [r9+r10]										; pointer to array address of name ordinals 
	mov r12w, word ptr[r10+rdx*2]							; ordinal number
	movzx r12, r12w
	mov r10d, dword ptr [r11+01ch]							; Virtual offset Address of Functions name field
	lea r10, [r9+r10]										; pointer to function array	
	mov r10d, dword ptr[r10+r12*4]							; Api Address VirtualOffset
	lea r10, [r9+r10]
	mov rax, r10
 	
	
	pop r13
	pop r12
	pop rbx
	ret
	
SyscallBaseFinder_ endp



;Prototype: char* GetBaseAddressExportFunc_(char* baseDll, char* exportFunctionToCall, size_t lenExportFunctionName);
GetBaseAddressExportFunc_ proc

	push rbx
	push rsi
	push rdi
	push rbp
	push r12
	push r13
	push r14
	push r15
	
	; rcx:	baseDll
	; rdx:	exportFunctionToCall
	; r8:	lenExportFunctionName

	;Get to the section headers and retrieve the file offset for the  Export Directory
	lea r9, [rcx]													; save DllBaseAddr
	mov r10d, dword ptr [r9+03ch]									; r8+3ch = e_lfanew (offset to NT Header)	
	mov r11d, dword ptr [r9+r10+018h+070h]							; base + [base+3ch] + 18h + 70h? = pointer to export table	

	; find the number of sections
	mov r12d, dword ptr[rcx+03ch]
	mov r13w, word ptr[rcx+r12+04h+02h]								; rcx-> Base, r12-> offset NtHeaders + 04h[File Headers] + 02[NumberOfSections]
	movzx r13, r13w													; r13-> NumberOfSections
	
	mov r14w, word ptr[rcx+r12+04h+010h]
	movzx r14, r14w													; r14-> SizeOfOptionalHeader
	
	; traverse to the Section headers
	lea r15, [rcx+r12]
	lea r15,[r15+018h+r14]											; r15-> start of SectionHeaders

	mov edi, dword ptr[r15+0ch]
	push rdi														; push virtual address of .text section for later use
	mov edi, dword ptr[r15+014h]	
	push rdi														; push file offset of .text section for later use
	
RepeatCheck:	
	; compare the virtual offset and see in which range does the offset for Export Directory falls
	mov edi, dword ptr[r15+0ch]										; rdi-> VirtualAddress of Section
	mov ebx, dword ptr[r15+08h]										; [r15+08h]-> VirtualSize
	add edi, ebx													;
	cmp r11d, edi
	jl FoundSection
	add r15, 40
	jmp RepeatCheck
FoundSection:
	mov r12d, dword ptr[r15+014h]									; rsi-> PointerToRawData	

	; now use the pointer to retrieve the base address of the function
	mov ebx, r11d
	mov r13d, dword ptr[r15+0ch]									; virtual offset of section in which export directory resides
	sub ebx, r13d													; get the virtual offset from start of section 
	add rbx, r12													; add offset to teh raw pointer to Section to get to the Export directory
	
	; start traversing the Export Directory
	mov r15, rbx													; rbx-> file offset to the export directory table
	lea r15, [r15+r9]
	
	mov r11d,  dword ptr[r15+020h]									; r12-> file offset Export directory
	sub r11d, r13d
	add r11d, r12d																								
	lea r11, [r11+r9]												; pointer to function names array
	
	xor rbx, rbx
	
RepeatCheck2:
	mov edi, dword ptr[r11+rbx*4]									; address of name of the first API
	sub edi, r13d
	add edi, r12d													
	lea rdi, [rdi+r9]												; pointer API name in Functions name array
	lea rsi, [rdx]													; Pointer API name passed as parameter
	
	xor rcx, rcx
	
CompareNextByte:
	mov al, byte ptr[rsi+rcx]
	cmp byte ptr[rdi+rcx], al
	jne NextString
	inc rcx
	cmp rcx, r8
	jge ApiFound
	jmp CompareNextByte
NextString:
	inc rbx															; rbx-> offset at which the export functions offset is located inside Functions name array
	jmp RepeatCheck2
	
ApiFound:
	mov r10d, dword ptr[r15+024h]							; Virtual offset Address of name  ordinals field
	sub r10d, r13d
	add r10d, r12d											
	lea r10, [r10+r9]										; file offset Address of name ordinals field

	mov r14w, word ptr[r10+rbx*2]							; ordinal number
	movzx r14, r14w

	mov r10d, dword ptr[r15+01ch]							; Virtual offset Address of Functions name field				
	sub r10d, r13d
	add r10d, r12d											
	lea r10, [r10+r9]										; file offset Address of Functions name field	

	mov r10d, dword ptr[r10+r14*4]							; Export function address VirtualOffset
	; get the virtual offset and file offset for the .text section
	pop r12													; file offset .text section
	pop r13													; Virtual offset .text section
	sub r10d, r13d
	add r10d, r12d
	lea r10, [r10+r9]
	mov rax, r10											;Export Function address file offset
	
	pop r15
	pop r14
	pop r13
	pop r12
	pop rbp
	pop rdi
	pop rsi
	pop rbx
	ret
	

GetBaseAddressExportFunc_ endp


Mysegment ends

end
